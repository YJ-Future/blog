# 深入拆解JVM
## 01 java代码怎么运行
- **java代码的运行方式**  
双击jar包运行、命令行、浏览器。依赖于JRE，java运行时环境。C++则不需要额外的运行时环境，编辑器把代码编译成机器码，直接可运行。
- **JRE中有什么**   
  包括运行java程序必需的组件：java虚拟机、java核心类库等
- **JDK中有什么**    
  包括JRE、以及开发和诊断工具
- **为什么java需要在jvm中运行**  
    java源代码编译成java字节码文件，然后运行在jvm中，而不是由编译器直接编译成机器码，直接运行在硬件上。  
    - 平台无关性    
    使用jvm java虚拟机屏蔽操作系统平台差异。在不同的操作系统平台提供不同的jvm，可以运行相同的字节码文件。
    - 提供托管环境  
    比如提供自动内存管理、垃圾回收等功能
- jvm具体怎样运行java字节码
    - jvm运行时数据区划分
        - 线程共享：
            - 堆：用于存放对象实例。
            - 方法区：用于方法被加载的类信息、常量、静态变量、JIT编译生成的代码等数据。
        - 线程私有：
            - java方法栈：每个方法开始执行时，都会在该线程对应的java方法栈中创建一个栈帧，栈帧中存放内容：局部变量表、操作数栈、动态链接、方法出口等。执行完该方法，则对应栈帧从栈中移出。栈帧的大小是提前计算好的，且不要求在内存空间中连续分布。
            - 本地方法栈：用于C++编写的native方法，类似java方法栈。
            - PC寄存器：存放当前线程执行字节码的行号。
    - 虚拟机角度  
        1. 把编译好的java字节码文件加载到jvm中
        2. 把加载好的java类存放到jvm的方法区中
        3. jvm执行方法区中的代码
    
    - 硬件角度  
        java字节码无法直接运行，需要jvm把java字节码翻译成机器码。在HotSpot中，翻译方式有两种： 
        - 解释执行：逐条将字节码翻译成机器码，然后执行。
        - 及时编译（JIT）：将一个方法中包含的所有字节码编译成机器码之后再执行。
          
        优缺点对比：  
        
        | | 优点 | 缺点 |
        |:---:|:---:|:---:|
        |解释执行|不需要等待编译<br>能够让程序快速启动执行|执行效率较低|
        |及时编译|执行效率高|编译需要耗费相对较长时间|
        
        HotSpot默认采用混合模式：先解释执行字节码，然后将反复执行的热点代码，以方法为单位进行及时编译。
- jvm运行效率  
HotSpot采用多种技术提升启动性能、以及峰值性能。技术就包括及时编译。  
及时编译建立在二八定律假设上，百分之二十的代码占用了百分之八十的计算资源。对于百分之八十不常用的代码，使用解释执行方法运行；对于百分之二十的热点代码，采用及时编译成机器码，提高运行效率。  
及时编译相比于静态编译具有的优势：  
及时编译能获取到程序运行时的统计信息，根据运行时信息可以做出更多的优化，提高程序运行效率。  
例子：  
java面向对象具有多态的特性，对于一个虚方法调用，可能会对应多个目标方法，其实往往程序运行中只使用到其中一个，那么可以在及时编译时，直接使用目标方法，省去虚方法调用开销。  

HotSopt内置多个及时编译器：C1、C2、Graal（java10正式引入的实验性及时编译器）。  
 - C1：Client编译器，面向对启动性能有要求的客户端GUI程序。优化手段相对简单，编译时间较短，执行效率相对较低。
 - C2: Server编译器，面向对峰值性能有要求的服务端程序。优化手段相对复杂，编译时间较长，但执行效率较高。  
 java7开始，HotSpot默认采用分层编译，热点方法首先被C1编译，之后热点中的热点方法会被C2编译。  
 HotSpot即使编译会在单独的编译线程中进行，避免对应用的正常运行造成影响。
 HotSpot会根据CPU数量设置编译线程的数量，然后编译线程的数量按照1：2比例分配给C1和C2及时编译器。
          
## 02 Java的基本类型
java基本类型：byte、short、char、boolean、int、long、float、double。
  
类型|值域|默认值|虚拟机内部符号    
:---:|:---:|:---:|:---:
boolean|{false,true}|false|Z
byte|[-128,127] (-2<sup>7</sup>,2<sup>7</sup>-1)|0|B
short|[-32768,32767] (-2<sup>15</sup>,2<sup>15</sup>-1)|0|S
char|[0,65535] (0,2<sup>16</sup>)|'\u0000'|C
int|[-2<sup>31</sup>,2<sup>31</sup>-1]|0|I
long|[-2<sup>63</sup>,2<sup>63</sup>-1]|0L|L
float| |+0.0F|F
double| | +0.00D|D
默认值在内存中都是0  
- boolean类型  
java语言规范中boolean类型只有两种值：true、false。boolean类型被映射成init类型：true映射成1，false映射成0。  
java虚拟机规范要求java编译器也要遵守这个编码规范，用整数相关字节码实现逻辑运算、boolean类型条件跳转。  
可以通过使用字节码编辑工具修改boolean类型变量的值为0、1之外的整数，这样字节码工具比如：AsmTools(OpenJDK中包含)、ASM等。  
- java基本类型的大小  
    - java栈  
    jvm每调用一个java方法，创建一个栈帧。栈帧两个主要组成部分：局部变量区、字节码操作数栈。局部变量区：局部变量、实例方法this指针、  
    方法参数。jvm规范中，局部变量区相当于一个数组，long、double占用两个数组单元存储、其他基本数据类型和引用类型值占用一个单元，一个单元   
    占用（32位HotSpot中占用4个字节、64位占用8个字节）
    - java堆  
    在java堆中byte、char、short三种类型字段和数组单元分别占用一个字节、两个字节、两个字节。boolean字段占用一个字节，boolean数组使用byte  
    数组实现。为了保证java堆中的boolean类型字段值合法，HotSpot在存储时显式进行掩码操作，只取最有一位值存放boolean字段或数组中（奇数则为1，  偶数为0）。
      
jvm的算数运算几乎全部依赖于操作数栈，需要将jvm堆中的boolean、byte、short加载到操作数栈中，然后把操作数栈中的值当做int类型运算。  
## 03 jvm如何加载java类  
jvm把java类的字节码变成内存中的类，大致经过了三个步骤：加载、连接、初始化。  
需要jvm从字节码变成内存中的类类型（必须经过加载过程的类型）包括：类、接口。java语言的类型可分为两大类：基本类型、引用类型。java基本类型是由jvm预先定义好的，数组类由jvm直接生成。泛型参数会在编译过程中被擦除。  
java字节码字节流来源：java编译器编译java源码文件生成的class文件、程序内部直接生成、从网络中获取的字节流。这些字节流会由jvm加载到jvm中，然后成为内存中的类或接口。  
### 加载
加载是指查找字节流。查找字节流需要使用类加载器（Class Loader）来完成。  
- 启动类加载器：Bootstrap ClassLoader 由C++代码实现。负责加载JAVA_HOME\lib目录下、或者使用-Xbootclasspath指定的路径中，包含的启动类加载器可以识别的类（按照文件名称识别），比如rt.jar。
- java.lang.ClassLoader子类
    - 扩展类加载器：Extension ClassLoader 由sun.misc.Launcher$ExtClassLoader实现，负责加载JAVA_HOME\lib\ext目录下、或者java.ext.dirs系统变量指定的路径中的所有类库。
    - 应用类加载器: System ClassLoader 由sun.misc.Launcher$AppClassLoader实现，负责加载classpath指定的应用程序类库。
主要的三个类加载器层次关系：应用类加载器 -》 扩展类加载器 -》 启动类加载器  
类加载器之间的层次关系称为双亲委派模型，要求：除了启动类加载器之外的所有类加载器都要有自己的父类加载器。具体双亲委派加载类的过程：
        - 将加载请求发送给父类加载器去完成类加载过程
        - 父类加载器同样会将加载请求交给自己的父类加载器
        - 如果父类加载器没有加载到请求加载的类，则尝试自己去加载  
java9中，扩展类加载器改成了平台类加载器，引入了模块系统的概念。类加载器起到命名空间的作用，在jvm中，一个类的唯一标示为：加载它的类加载器 + 类的全名。  
### 链接
链接是把创建的类合并到jvm中，让类可以执行的过程。链接过程分三步走：验证、准备、初始化。  
- 验证：校验被加载的类是否满足jvm的约束要求。比如验证字节码开头四个字节应该是魔数（CAFE BABE）。  
> 魔数通常用于标示文件格式类型。具体魔数的介绍：https://en.wikipedia.org/wiki/Magic_number_%28programming%29   
  java字节码使用CAFE BABE作为魔数的原因：https://en.wikipedia.org/wiki/Java_class_file 的Magic Number部分  
    
- 准备：为被加载器类的静态字段分配内存。
- 解析：将符号引用解析成实际引用。   
符号引用：在类的class文件被加载到jvm中之前，类还不知道自己使用的其他类、其他类的方法、字段在内存中的地址。java编译器在编译java源代码时，会将这些对类、方法、字段的引用使用一个符号引用代替。比如：   
对于一个方法调用，java编译器会生成一个符号引用来代替，这个符号引用包含：目标方法所在的类名、目标方法名称、参数类型、返回值类型。  
解析的过程就是把这种符号引用解析成实际引用，如果涉及到引用的类或者方法和字段所属的类还未被加载，则触发对这种未被加载的类的加载。  
jvm规范规定在执行字节码之前，要求完成涉及到的符号引用的解析，没有要求必须要在链接阶段完成解析。  
### 初始化
java代码中，初始化一个静态字段，可以直接赋值，也可以在静态代码段中进行赋值。
- 直接赋值的final修饰的基本类型或者字符串类型静态字段，java编译器会标记该字段为ConstantValue，该字段的初始化直接由jvm完成。  
- 除了上面这种情况之外的字段直接赋值、所有静态代码块中代码，会被java编译器放到同一个方法中，这个方法名称是<clinit>。这个方法jvm通过加锁来保证仅被执行一次。
jvm规范中规定的触发初始化的多种条件：  
- jvm启动时，初始化用户指定的主类  
- 通过new关键字创建类的实例对象，初始化这个类  
- 静态方法调用，静态方法所在的类会被初始化
- 静态字段访问，静态字段所在的类会被初始化
- 子类初始化，子类的父类需要被初始化  
- 接口定义了default方法，直接实现或者间接实现该接口的类初始化时，会触发该接口的初始化   
- 使用反射api调用类时，触发这个类初始化  
单例模式的例子：
```
public class Singleton {
    private Singleton() {}
    private static class LazyHolder 
        static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance(){
        return LazyHolder.INSTANCE;
    }
}
```
类的初始化是线程安全的，并且只会执行一次，所以可以利用类初始化的特性实现延迟加载单例模式。  
## 04 jvm如何执行方法调用？  
### 重载和重写  
- 重载  
    - 同一个类中：多个方法，名字相同，参数类型不同，这些方法直接的关系称为重载。  
    - 子类和父类中：子类中定义了和父类中非私有方法同名的方法，且两个方法的参数类型不同，则这两个方法之间关系为重载。  
    
    方法重载在编辑过程中就可以完成识别。具体识别具体的目标方法的规则：  
    - 在不考虑自动拆箱装箱和可变长参数（比如：Object ... xxx）情况下，匹配目标方法。  
    - 在考虑自动拆箱装箱、不考虑可变长参数的情况下，匹配目标方法。  
    - 在考虑自动拆箱装箱、考虑可变长参数的情况下，匹配目标方法。  
    - 优先考虑更加具体的类型，比如重载的方法中，一个方法的参数类型为String，另一个的参数类型是Object，优先考虑String类型的方法。  
- 重写
子类和父类中方法的关系，如果子类中存在一个方法和父类中的一个非私有非静态的方法同名，且这两个方法参数类型相同，则这两个方法之间的关系为重写，子类中的方法重写了父类中的方法。  
如果子类的方法和父类的静态非私有方法同名，且参数类型相同，则子类的方法**隐藏**了父类的方法。  
### jvm的静态绑定和动态绑定  
jvm中的静态绑定：在解析时能够解析出来目标方法称为静态绑定。  
jvm中的动态绑定：需要在运行过程中根据调用者的动态类型识别目标方法称为动态绑定。  
java字节码中和调用相关的五种指令：  
- invokestatic：调用静态方法
- invokespecial：调用实例私有方法、构造器；super关键字调用父类实例方法、构造器；所实现接口的默认方法（default）  
- invokevirtual：调用非私有实例方法  
- invokeinterface：调用接口方法  
- invokedynamic：调用动态方法  
静态绑定：invokestatic、invokespecial、final修饰的非私有实例方法 invokevirtual  
动态绑定：invokeinterface、invokevirtual  
### 符号引用  
java代码编译过程中，不知道目标方法的具体内存地址，编译器会使用符号来表示目标方法。符号引用包括：目标方法所在的类或接口名字、方法名、方法描述符。   
符号引用存放在class文件的常量池中，使用 javap -v xxx 命令可以查看到每个类的常量池。   
接口符号引用：目标方法是接口方法  
非接口符号引用：目标方法非接口方法   
非接口符号引用，假设符号引用对应的类是C，则jvm解析符号引用过程：  
1. 在C中查找符合名字及方法描述符的方法。  
2. 1中没有找到，则在C的父类中继续找，一直找到Object类。  
3. 2中没找到，则在C直接或间接实现的接口中找，要求找到的目标方法必须是非私有、非静态的。如果目标方法在间接实现的接口中，则需要满足C和该接口直接没有其他符合条件的目标方法。如果存在多个符合条件的  
目标方法，则任意返回其中的一个。  

接口符号引用，假设符号引用对应接口I，则jvm解析符号引用过程：
1. 在I中查找符合名字和方法描述符的方法。  
2. 1没有找到，则在Object类中公有实例方法中找。  
3. 2没找到，则在I的超接口中找，具体要求和非接口符号引用解析一样。  
经过解析，符号引用被解析成实际引用。静态绑定的符号引用，可以解析得到一个指向目标方法的指针。动态绑定的符号引用，则解析得到一个方法表的索引。   




                


    
        
       
    